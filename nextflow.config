/*
 * -------------------------------------------------
 *  nf-core/evoverse Nextflow config file
 * -------------------------------------------------
 * Default config options for all environments.
 */

// Global default params, used in configs
params {

  // Workflow flags
  outdir = null
  input = null
  genome = null
  fasta = null

  tools = "mobster,viber,pyclone-vi,sparsesignatures,sigprofiler"  // Default Subclonal deconvolution & Signature deconvolution tools
  remove_tail = "all"                 // VAF deconvolution - general
  publish_dir_mode = "copy"
  publish_dir_mode_genome_sigprofiler = "move"

  // VEP
  download_cache_vep = null
  vep_cache = null

  vep_cache_version = null
  vep_species = null
  vep_genome = null
  vep_custom_args = "--everything --filter_common --per_gene --total_length --offline --format vcf"

  // ANNOTATE_DRIVERS
  drivers_table = null
  dndscv_refcds_rda = null
  dndscv_qmis_cv = 0.1
  dndscv_qtrunc_cv = 0.1
  dndscv_qallsubs_cv = 0.1 


  // vcf2CNAqc
  vcf_filter_mutations = "TRUE"
  
  // SparseSig
  bsg_hs37 = "/orfeo/LTS/CDSLab/LT_storage/shared/BS_genome/bsg_hs37d5.rds"

  // MAFTOOLS
  maftools_rmOutlier = "TRUE"
  maftools_addStat = "NULL"
  maftools_titvRaw = "TRUE"
  maftools_showBarcodes = "FALSE"
  maftools_dashboard = "TRUE"
  maftools_top = "10"
  maftools_minMut =  "NULL"
  maftools_genes = "NULL"
  maftools_altered = "FALSE"
  maftools_removeNonMutated = "TRUE"
 
  // CNAqc
  cnaqc_matching_strategy = "rightmost"
  cnaqc_karyotypes = "c('1:0', '1:1', '2:0', '2:1', '2:2')"
  cnaqc_min_karyotype_size = "0"
  cnaqc_min_absolute_karyotype_mutations = "100"
  cnaqc_p_binsize_peaks = "0.005"
  cnaqc_matching_epsilon = "NULL"
  cnaqc_purity_error = "0.05"
  cnaqc_vaf_tolerance = "0.015"
  cnaqc_n_bootstrap = "1"
  cnaqc_kernel_adjust = "1"
  cnaqc_kde = "TRUE"
  cnaqc_starting_state_subclonal_evolution = "1:1"
  cnaqc_cluster_subclonal_CCF = "FALSE"
  cnaqc_muts_per_karyotype = "25"
  cnaqc_cutoff_QC_PASS = "0.1"
  cnaqc_method = "ENTROPY"
  cnaqc_plot_cn = "absolute"

  // join_CNAqc
  joincnaqc_qc_filter = "FALSE"
  joincnaqc_keep_original = "TRUE"

  // Coupled WGS-scRNA
  vartrix_scoring_method = 'consensus'    // default value for VARTRIX
  vartrix_padding = 100 // default value for VARTRIX
  vartrix_umi = false // default value for VARTRIX


  // VAF deconvolution - pyclonevi
  pyclonevi_n_cluster = 20    // default value for PYCLONEVI
  pyclonevi_density = 'beta-binomial' // default value for PYCLONEVI
  pyclonevi_n_grid_point = 100 // default value for PYCLONEVI
  pyclonevi_n_restarts = 100 // default value for PYCLONEVI

  // VAF deconvolution - mobster
  mobster_K = "1:5"
  mobster_samples = "5"
  mobster_init = "peaks"
  mobster_tail = "c(TRUE,FALSE)"
  mobster_epsilon = "1e-10"
  mobster_maxIter = "250"
  mobster_fit_type = "MM"
  mobster_seed = "12345"
  mobster_model_selection = "reICL"
  mobster_trace = "FALSE"
  mobster_parallel = "TRUE"
  mobster_pi_cutoff = "0.02"
  mobster_n_cutoff = "10"
  mobster_auto_setup = "NULL"
  mobster_silent = "FALSE"

  // VAF deconvolution - VIBER
  viber_K = "10"
  viber_samples = "10"
  viber_alpha_0 = "1e-06"
  viber_a_0 = "1"
  viber_b_0 = "1"
  viber_maxIter = "5000"
  viber_epsilon_conv = "1e-10"
  viber_q_init = "prior"
  viber_trace = "FALSE"
  viber_binomial_cutoff = "0.05"
  viber_dimensions_cutoff = "1"
  viber_pi_cutoff = "0.02"
  viber_re_assign = "FALSE"

  // Clone tree - ctree
  ctree_sspace_cutoff = "10000"
  ctree_n_sampling = "5000"
  ctree_store_max = "100"

  // Mutational Signature Deconvolution - SparseSignatures
  // nmfLassoCV
  sparsesignatures_K = "2:10"
  sparsesignatures_background_signature = "NULL" 
  sparsesignatures_beta = "NULL"
  sparsesignatures_normalize_counts = "TRUE"
  sparsesignatures_nmf_runs = "10"
  sparsesignatures_iterations = "30" 
  sparsesignatures_max_iterations_lasso = "10000"
  sparsesignatures_num_processes = "Inf"
  sparsesignatures_cross_validation_entries = "0.01"
  sparsesignatures_cross_validation_repetitions = "50"
  sparsesignatures_cross_validation_iterations = "5"
  sparsesignatures_lambda_values_alpha = "c(0.00, 0.01, 0.05, 0.10)"
  sparsesignatures_lambda_values_beta = "c(0.01, 0.05, 0.1, 0.2)"
  sparsesignatures_lambda_rate_alpha = "0"
  sparsesignatures_verbose = "TRUE"
  sparsesignatures_seed = "12345"


  // Download reference genome Sigprofiler
  download_genome_sigprofiler_reference_genome = "GRCh37"
  download_genome_sigprofiler_sigprofiler_genome_path = "signature_deconvolution/Sigprofiler/genome/"
  download_sigprofiler_genome = true
  genome_installed_path = null

  // Mutational Signature Deconvolution - SigProfiler
  sigprofiler_reference_genome = "GRCh37"
  sigprofiler_exome = "False"
  sigprofiler_volume = "signature_deconvolution/Sigprofiler/genome/"
  sigprofiler_input_type = "matrix"
  sigprofiler_context_type = "96,DINUC,ID"
  sigprofiler_minimum_signatures = "1"
  sigprofiler_maximum_signatures = "25"
  sigprofiler_nmf_replicates = "100"
  sigprofiler_resample = "True"
  sigprofiler_seeds = "random"
  sigprofiler_matrix_normalization = "gmm"
  sigprofiler_nmf_init = "random"
  sigprofiler_min_nmf_iterations = "10000"
  sigprofiler_max_nmf_iterations = "1000000"
  sigprofiler_nmf_test_conv = "10000"
  sigprofiler_nmf_tolerance = "1e-15"
  sigprofiler_cpu = "-1"
  sigprofiler_stability = "0.8"
  sigprofiler_min_stability = "0.2"
  sigprofiler_combined_stability = "1.0"
  sigprofiler_cosmic_version = "3.4"
  sigprofiler_make_decomposition_plots = "True"
  sigprofiler_collapse_to_SBS96 = "True"
  sigprofiler_get_all_signature_matrices = "True"
  sigprofiler_export_probabilities = "True"

  // TINC
  tinc_vaf_range_tumour = "c(0, 0.7)"
  tinc_cutoff_miscalled_clonal = "0.6"
  tinc_cutoff_lv_assignment = "0.75"
  tinc_N = "20000"
  tinc_fast = "TRUE"
  tinc_normal_contamination_lv = "3"


  // Boilerplate options
  name = false
  email = false
  email_on_fail = false
  plaintext_email = false
  monochrome_logs = false
  help = false
  igenomes_base = 's3://ngi-igenomes/igenomes/'
  tracedir = "${params.outdir}/pipeline_info"
  igenomes_ignore = false
  custom_config_version = 'master'
  custom_config_base = "https://raw.githubusercontent.com/nf-core/configs/${params.custom_config_version}"
  hostnames = false
  config_profile_description = false
  config_profile_contact = false
  config_profile_url = false

  // Defaults only, expecting to be overwritten
  max_memory = 128.GB
  max_cpus = 16
  max_time = 240.h

}

// Container slug. Stable releases should specify release tag!
// Developmental code should specify :dev
process.container = 'nfcore/tumourevo:dev'

// Load base.config by default for all pipelines
includeConfig 'conf/base.config'
//includeConfig 'conf/params.config'
includeConfig 'conf/modules/ensemblvep.config'
includeConfig 'conf/modules/formatter.config'
includeConfig 'conf/modules/lifter.config'
includeConfig 'conf/modules/cnaqc.config'
includeConfig 'conf/modules/driver_annotation.config'
includeConfig 'conf/modules/pyclonevi.config'
includeConfig 'conf/modules/viber.config'
includeConfig 'conf/modules/mobsterh.config'
includeConfig 'conf/modules/joint_fit.config'
includeConfig 'conf/modules/tinc.config'
includeConfig 'conf/modules/ctree.config'
includeConfig 'conf/modules/sparsesignatures.config'
includeConfig 'conf/modules/sigprofiler.config'

// Load nf-core custom profiles from different Institutions
try {
  includeConfig "${params.custom_config_base}/nfcore_custom.config"
} catch (Exception e) {
  System.err.println("WARNING: Could not load nf-core/config profiles: ${params.custom_config_base}/nfcore_custom.config")
}

plugins {
  id 'nf-schema@2.0.0'
}

profiles {
  conda { process.conda = "${baseDir}/environment.yml" }
  debug { process.beforeScript = 'echo $HOSTNAME' }
  docker {
    docker.enabled = true
    // Avoid this error:
    //   WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.
    // Testing this in nf-core after discussion here https://github.com/nf-core/tools/pull/351
    // once this is established and works well, nextflow might implement this behavior as new default.
    docker.runOptions = '-u \$(id -u):\$(id -g)'
  }
  singularity {
    singularity.enabled = true
    singularity.autoMounts = true
  }
  test {
    includeConfig 'conf/test.config'
  }
}

// Load igenomes.config if required
if (!params.igenomes_ignore) {
  includeConfig 'conf/igenomes.config'
}

// Export this variable to prevent local Python libraries from conflicting with those in the container
env {
  PYTHONNOUSERSITE = 1
}

// Capture exit codes from upstream processes when piping
process.shell = ['/bin/bash', '-euo', 'pipefail']

timeline {
  enabled = true
  file = "${params.tracedir}/execution_timeline.html"
  timeline.overwrite = true
}
report {
  enabled = true
  file = "${params.tracedir}/execution_report.html"
  report.overwrite = true
}
trace {
  enabled = true
  file = "${params.tracedir}/execution_trace.txt"
  trace.overwrite = true
}
dag {
  enabled = true
  file = "${params.tracedir}/pipeline_dag.svg"
  dag.overwrite = true
}

manifest {
  name = 'nf-core/evoverse'
  author = 'Nicola Calonaci, Elena Buscaroli, Katsiaryna Davydzenka, Giorgia Gandolfi, Virginia Gazziero, Asad Sadr, Lucrezia Valeriani and Giulio Caravagna'
  homePage = 'https://github.com/nf-core/evoverse'
  description = 'Analysis pipleine to model tumour clonal evolution from WGS data (driver annotation, quality control of copy number calls, subclonal and mutational signature deconvolution)'
  mainScript = 'main.nf'
  nextflowVersion = '>=19.10.0'
  version = '1.0dev'
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
  if (type == 'memory') {
    try {
      if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
        return params.max_memory as nextflow.util.MemoryUnit
      else
        return obj
    } catch (all) {
      println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
      return obj
    }
  } else if (type == 'time') {
    try {
      if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
        return params.max_time as nextflow.util.Duration
      else
        return obj
    } catch (all) {
      println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
      return obj
    }
  } else if (type == 'cpus') {
    try {
      return Math.min( obj, params.max_cpus as int )
    } catch (all) {
      println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
      return obj
    }
  }
}
